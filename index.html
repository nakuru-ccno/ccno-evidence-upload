<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evidence Upload (Offline Ready)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; }
    label { display: block; margin-top: 10px; font-weight: bold; }
    input, select { width: 100%; padding: 8px; margin-top: 4px; }
    button { margin-top: 15px; padding: 10px 15px; background-color: #b22222; color: white; border: none; cursor: pointer; }
    button:hover { background-color: #7f0000; }
    #result { margin-top: 15px; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Evidence Upload Form</h2>

  <form id="uploadForm">
    <label for="evidenceName">Evidence Name</label>
    <input type="text" id="evidenceName" name="evidenceName" placeholder="e.g., CME on Family Planning Methods" required />

    <label for="category">Evidence Category (Folder ID)</label>
    <input type="text" id="category" name="category" placeholder="Paste folder ID here" required />

    <label for="subCounty">Sub County</label>
    <input type="text" id="subCounty" name="subCounty" placeholder="e.g., Nakuru East" required />

    <label for="files">Choose PDF files (max 3MB each, up to 10 files)</label>
    <input type="file" id="files" name="files" accept="application/pdf" multiple required />

    <button type="submit">Upload</button>
  </form>

  <div id="result"></div>

<script>
  // ---------- CONFIG ----------
  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbxMex9rlVYM9AHiQotfCbpwY7VZcWlCnt3E6_NhXmj__npzRJHUsbNaaudGyzS9Fn2-GA/exec';

  // ---------- IndexedDB HELPERS ----------
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open('EvidenceDB', 1);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('submissions')) {
          db.createObjectStore('submissions', { keyPath: 'id', autoIncrement: true });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function saveSubmission(submission) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('submissions', 'readwrite');
      tx.objectStore('submissions').add(submission);
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
  }

  async function getAllSubmissions() {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('submissions', 'readonly');
      const req = tx.objectStore('submissions').getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }

  async function deleteSubmission(id) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction('submissions', 'readwrite');
      tx.objectStore('submissions').delete(id);
      tx.oncomplete = resolve;
      tx.onerror = () => reject(tx.error);
    });
  }

  // ---------- NETWORK ----------
  async function sendSubmission(data) {
    const formData = new FormData();
    formData.append('evidenceName', data.evidenceName);
    formData.append('category', data.category);
    formData.append('subCounty', data.subCounty);
    // Rebuild File objects from blobs if needed
    (data.files || []).forEach((f, i) => {
      // If coming from IndexedDB, f may be a plain object with name & type & blob
      if (f instanceof File) {
        formData.append('files', f);
      } else {
        const blob = new Blob([new Uint8Array(f.buffer)], { type: f.type || 'application/pdf' });
        const file = new File([blob], f.name || `file-${i+1}.pdf`, { type: blob.type });
        formData.append('files', file);
      }
    });

    const res = await fetch(ENDPOINT, { method: 'POST', body: formData });
    // Expect JSON back
    const json = await res.json().catch(() => ({ status: 'error', message: 'Invalid JSON response' }));
    if (!res.ok || json.status !== 'success') {
      throw new Error(json.message || `HTTP ${res.status}`);
    }
    return json;
  }

  // Serialize Files for IndexedDB (since Files aren’t structured-clone friendly everywhere)
  async function filesToStorable(files) {
    const out = [];
    for (const f of files) {
      const arrayBuf = await f.arrayBuffer();
      out.push({
        name: f.name,
        type: f.type,
        size: f.size,
        buffer: Array.from(new Uint8Array(arrayBuf)) // store as array of numbers
      });
    }
    return out;
  }

  // ---------- UI / FORM ----------
  const form = document.getElementById('uploadForm');
  const resultDiv = document.getElementById('result');

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    resultDiv.textContent = '';

    const files = Array.from(form.files.files);
    if (files.length === 0) return alert('Please select at least one PDF file.');
    if (files.length > 10) return alert('You can upload up to 10 files only.');
    for (const f of files) {
      if (f.type !== 'application/pdf') return alert(`File ${f.name} is not a PDF.`);
      if (f.size > 3 * 1024 * 1024) return alert(`File ${f.name} exceeds 3MB size limit.`);
    }

    const submission = {
      evidenceName: form.evidenceName.value.trim(),
      category: form.category.value.trim(),
      subCounty: form.subCounty.value.trim(),
      files
    };

    if (!navigator.onLine) {
      // Save a storable copy
      const storable = {
        evidenceName: submission.evidenceName,
        category: submission.category,
        subCounty: submission.subCounty,
        files: await filesToStorable(submission.files),
        createdAt: Date.now()
      };
      await saveSubmission(storable);
      resultDiv.style.color = 'orange';
      resultDiv.textContent = '📦 Saved offline. Will upload when you’re online.';
      form.reset();
      return;
    }

    try {
      const res = await sendSubmission(submission);
      resultDiv.style.color = 'green';
      resultDiv.textContent = `✅ Uploaded ${res.files?.length ?? submission.files.length} file(s) successfully!`;
      form.reset();
    } catch (err) {
      resultDiv.style.color = 'red';
      resultDiv.textContent = `❌ Upload failed: ${err.message}`;
    }
  });

  // Auto-sync when back online
  window.addEventListener('online', async () => {
    const queue = await getAllSubmissions();
    if (!queue.length) return;

    resultDiv.style.color = 'blue';
    resultDiv.textContent = `📤 Uploading ${queue.length} saved submission(s)...`;

    for (const item of queue) {
      try {
        await sendSubmission(item); // sendSubmission handles storable files too
        await deleteSubmission(item.id);
      } catch (err) {
        console.error('Retry failed', err);
      }
    }
    resultDiv.style.color = 'green';
    resultDiv.textContent = '✅ All saved submissions uploaded!';
  });

  // ---------- Service Worker ----------
  if ('serviceWorker' in navigator) {
    // If sw.js is in repo root, this is correct:
    navigator.serviceWorker.register('./sw.js').catch(console.error);
  }
</script>

<!-- Tawk.to: ensure your domain is allowed in Tawk dashboard -->
<!-- Start of Tawk.to Script -->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
  var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
  s1.async=true;
  s1.src='https://embed.tawk.to/689f96a3afd36319238be667/1j2nm8s6m';
  s1.charset='UTF-8';
  s1.setAttribute('crossorigin','*');
  s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!-- End of Tawk.to Script -->

</body>
</html>

