<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evidence Upload (Offline Ready)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; }
    label { display: block; margin-top: 10px; font-weight: bold; }
    input, select { width: 100%; padding: 8px; margin-top: 4px; }
    button { margin-top: 15px; padding: 10px 15px; background-color: #b22222; color: white; border: none; cursor: pointer; }
    button:hover { background-color: #7f0000; }
    #result { margin-top: 15px; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Evidence Upload Form</h2>
  <form id="uploadForm">
    <label for="evidenceName">Evidence Name</label>
    <input type="text" id="evidenceName" name="evidenceName" required />

    <label for="category">Evidence Category (Folder ID)</label>
    <input type="text" id="category" name="category" required />

    <label for="subCounty">Sub County</label>
    <input type="text" id="subCounty" name="subCounty" required />

    <label for="files">Choose PDF files (max 3MB each, up to 10 files)</label>
    <input type="file" id="files" name="files" accept="application/pdf" multiple required />

    <button type="submit">Upload</button>
  </form>

  <div id="result"></div>

<script>
  const form = document.getElementById('uploadForm');
  const resultDiv = document.getElementById('result');
  const ENDPOINT = 'https://script.google.com/macros/s/AKfycbycb6MkCa9f8MNPTZyidHvZjeqP49Q48zm2q3AM8TNgd0CEdYwdc1IoMuWBigGjHoLh/exec';

  function saveToIndexedDB(data) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('EvidenceDB', 1);
      request.onupgradeneeded = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('submissions')) {
          db.createObjectStore('submissions', { autoIncrement: true });
        }
      };
      request.onsuccess = e => {
        const db = e.target.result;
        const tx = db.transaction('submissions', 'readwrite');
        tx.objectStore('submissions').add(data);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      };
      request.onerror = () => reject(request.error);
    });
  }

  function getAllSubmissions() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('EvidenceDB', 1);
      request.onsuccess = e => {
        const db = e.target.result;
        const tx = db.transaction('submissions', 'readonly');
        const store = tx.objectStore('submissions');
        const all = store.getAll();
        all.onsuccess = () => resolve(all.result);
        all.onerror = () => reject(all.error);
      };
    });
  }

  function clearSubmissions() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('EvidenceDB', 1);
      request.onsuccess = e => {
        const db = e.target.result;
        const tx = db.transaction('submissions', 'readwrite');
        tx.objectStore('submissions').clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      };
    });
  }

  async function sendSubmission(data) {
    const formData = new FormData();
    formData.append('evidenceName', data.evidenceName);
    formData.append('category', data.category);
    formData.append('subCounty', data.subCounty);
    data.files.forEach(file => formData.append('files', file));

    const response = await fetch(ENDPOINT, { method: 'POST', body: formData });
    return await response.json();
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    resultDiv.textContent = '';

    const files = Array.from(form.elements['files'].files);
    if (files.length === 0 || files.length > 10) {
      alert("Select 1–10 PDF files only.");
      return;
    }
    for (const f of files) {
      if (f.type !== 'application/pdf' || f.size > 3 * 1024 * 1024) {
        alert(`Invalid file: ${f.name}`);
        return;
      }
    }

    const submission = {
      evidenceName: form.evidenceName.value,
      category: form.category.value,
      subCounty: form.subCounty.value,
      files: files
    };

    if (!navigator.onLine) {
      await saveToIndexedDB(submission);
      resultDiv.style.color = 'orange';
      resultDiv.textContent = '📦 Saved offline. Will upload when you’re online.';
      form.reset();
    } else {
      try {
        const res = await sendSubmission(submission);
        if (res.status === "success") {
          resultDiv.style.color = 'green';
          resultDiv.textContent = `✅ Uploaded ${res.files.length} file(s) successfully!`;
          form.reset();
        } else {
          throw new Error(res.message);
        }
      } catch (err) {
        resultDiv.style.color = 'red';
        resultDiv.textContent = `❌ Upload failed: ${err.message}`;
      }
    }
  });

  window.addEventListener('online', async () => {
    const submissions = await getAllSubmissions();
    if (submissions.length > 0) {
      resultDiv.style.color = 'blue';
      resultDiv.textContent = `📤 Uploading ${submissions.length} saved submission(s)...`;
      for (const sub of submissions) {
        try {
          await sendSubmission(sub);
        } catch (err) {
          console.error("Retry failed", err);
        }
      }
      await clearSubmissions();
      resultDiv.textContent = '✅ All saved submissions uploaded!';
    }
  });
</script>

<script>
  // Register Service Worker for PWA support
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(console.error);
  }
</script>

<!-- Start of Tawk.to Script -->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/689f96a3afd36319238be667/1j2nm8s6m';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!-- End of Tawk.to Script -->

</body>
</html>
