<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Evidence Upload (Offline Ready)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; }
    label { display: block; margin-top: 10px; font-weight: bold; }
    input, select { width: 100%; padding: 8px; margin-top: 4px; }
    button { margin-top: 15px; padding: 10px 15px; background-color: #b22222; color: white; border: none; cursor: pointer; }
    button:hover { background-color: #7f0000; }
    #result { margin-top: 15px; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Evidence Upload Form</h2>
  <form id="uploadForm">
    <label for="evidenceName">Evidence Name</label>
    <input type="text" id="evidenceName" name="evidenceName" placeholder="e.g., CME on Family Planning Methods" required />

    <label for="category">Evidence Category (Folder ID)</label>
    <input type="text" id="category" name="category" placeholder="Paste folder ID here" required />

    <label for="subCounty">Sub County</label>
    <input type="text" id="subCounty" name="subCounty" placeholder="e.g., Nakuru East" required />

    <label for="files">Choose PDF files (max 3MB each, up to 10 files)</label>
    <input type="file" id="files" name="files" accept="application/pdf" multiple required />

    <button type="submit">Upload</button>
  </form>

  <div id="result"></div>

<script>
  const form = document.getElementById('uploadForm');
  const resultDiv = document.getElementById('result');
  const endpoint = 'https://script.google.com/macros/s/AKfycbycb6MkCa9f8MNPTZyidHvZjeqP49Q48zm2q3AM8TNgd0CEdYwdc1IoMuWBigGjHoLh/exec';

  // IndexedDB setup
  let db;
  const request = indexedDB.open('EvidenceDB', 1);
  request.onupgradeneeded = e => {
    db = e.target.result;
    db.createObjectStore('submissions', { keyPath: 'id', autoIncrement: true });
  };
  request.onsuccess = e => { db = e.target.result; };

  function saveOffline(data) {
    const tx = db.transaction('submissions', 'readwrite');
    tx.objectStore('submissions').add(data);
  }

  async function uploadOnline(data) {
    const fd = new FormData();
    fd.append('evidenceName', data.evidenceName);
    fd.append('category', data.category);
    fd.append('subCounty', data.subCounty);
    data.files.forEach(f => fd.append('files', new File([f.blob], f.name, { type: 'application/pdf' })));

    const res = await fetch(endpoint, { method: 'POST', body: fd });
    return res.json();
  }

  async function syncOfflineData() {
    const tx = db.transaction('submissions', 'readonly');
    const store = tx.objectStore('submissions');
    const all = await store.getAll();
    for (const entry of all) {
      try {
        const result = await uploadOnline(entry);
        if (result.status === "success") {
          const dtx = db.transaction('submissions', 'readwrite');
          dtx.objectStore('submissions').delete(entry.id);
        }
      } catch (err) {
        console.warn("Sync failed, will retry later", err);
      }
    }
  }

  // Handle form submit
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    resultDiv.textContent = '';

    const files = [...form.elements['files'].files];
    if (files.length === 0) return alert("Select a PDF.");
    if (files.length > 10) return alert("Max 10 files.");
    for (const f of files) {
      if (f.type !== 'application/pdf') return alert(`Not a PDF: ${f.name}`);
      if (f.size > 3 * 1024 * 1024) return alert(`Too large: ${f.name}`);
    }

    const data = {
      evidenceName: form.evidenceName.value,
      category: form.category.value,
      subCounty: form.subCounty.value,
      files: await Promise.all(files.map(async f => ({
        name: f.name,
        blob: await f.arrayBuffer()
      })))
    };

    if (navigator.onLine) {
      try {
        const res = await uploadOnline(data);
        if (res.status === "success") {
          resultDiv.style.color = 'green';
          resultDiv.textContent = `‚úÖ Uploaded ${res.files.length} file(s)`;
          form.reset();
        } else {
          resultDiv.style.color = 'red';
          resultDiv.textContent = `‚ùå Failed: ${res.message}`;
        }
      } catch (err) {
        saveOffline(data);
        resultDiv.style.color = 'orange';
        resultDiv.textContent = "üì¶ Saved offline, will upload later.";
      }
    } else {
      saveOffline(data);
      resultDiv.style.color = 'orange';
      resultDiv.textContent = "üì¶ Saved offline, will upload later.";
    }
  });

  // Sync when back online
  window.addEventListener('online', syncOfflineData);

  // Register service worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js');
  }
</script>

<!--Start of Tawk.to Script-->
<script type="text/javascript">
var Tawk_API=Tawk_API||{}, Tawk_LoadStart=new Date();
(function(){
var s1=document.createElement("script"),s0=document.getElementsByTagName("script")[0];
s1.async=true;
s1.src='https://embed.tawk.to/689f96a3afd36319238be667/1j2nm8s6m';
s1.charset='UTF-8';
s1.setAttribute('crossorigin','*');
s0.parentNode.insertBefore(s1,s0);
})();
</script>
<!--End of Tawk.to Script-->

</body>
</html>
